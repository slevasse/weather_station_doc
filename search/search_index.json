{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the weather station project documentation Project goal The simplified goal of the project is to design and implement a weather monitoring system based on simple weather stations (nodes). The data collected by each node is sent to a server where it is stored for further processing. The server also host a simple website where the data can be accessed. The project aim at developing the node hardware and software, and the server software. The true goal is to have produced nodes that can opperate autonomously in the rought alpine climate present in my montains (cold temperature (-30 C), heavy snowfall and strong winds (> 200 kmph)). However, before to be able to produce such nodes I feel like it would be better to have something that can opperate in nice climate (inside a house or in a city). Thus I will first focus on building a \"conventional\" weather monitoring system that I will then improve up to the point where it can be used where I indtend to. This project will be combined with another project of mine, the production of a cheap ultrasonic anemometer. I like to fly and having a good idea of the wind is crutial. However, anemometer are expensive and not fit for use in winter. Ultrasonic ones are better for use in harsh environement but they are ridiculously expensive, even if their operation is relatively simple. I do not intend to make some fancy app, pretty HW and all that bullshit. Just to make something to collect and visualise data in a simple and effective way. Everything will be public and open and I will gladly accept help from whoever will want to contribute. All in all if I end up with a thermometer in my bedroom that I can check from my phone I will bbe happy. Project motivation The motivation for this project is that there is no cheap environemental sensor that could survive the harsh winter we have where I live. This type of weather station is typicaly only used by governemental organisation or research center and they are too expensive / too large to be wide spread. Moreover, the data from these is not openly availiable. Project Timeline 14/04/2020 - Official start of the project Project milestones Mark I (city system) Produce a first prototype of node and server (breadboard mess type of thing). Produce integrated node for city use (semi-integrated in a custom PCB type of thing). MkI of the system completed (node, server, website). Mark II (Improved for harsh winter climate) Create a autonomous power and life-support system for the node. Improved node HW / SW to work with new power and life-support. Node MkII completed (might also call it winter node) Survived one winter MkII of the system completed (node, server, website). Existing similar system Here is a totaly non exhaustive list of similar projects. All of them are intended for city usage. Citizen efforts Hackair Luftdaten (Very similar to what I try to do, exept I want a more modular system..) aircarto (Project seems frozen..) airboxlab Sensebox (sort of for profit still..) For profit Air things HabitatMap openAQ","title":"Welcome"},{"location":"#welcome-to-the-weather-station-project-documentation","text":"","title":"Welcome to the weather station project documentation"},{"location":"#project-goal","text":"The simplified goal of the project is to design and implement a weather monitoring system based on simple weather stations (nodes). The data collected by each node is sent to a server where it is stored for further processing. The server also host a simple website where the data can be accessed. The project aim at developing the node hardware and software, and the server software. The true goal is to have produced nodes that can opperate autonomously in the rought alpine climate present in my montains (cold temperature (-30 C), heavy snowfall and strong winds (> 200 kmph)). However, before to be able to produce such nodes I feel like it would be better to have something that can opperate in nice climate (inside a house or in a city). Thus I will first focus on building a \"conventional\" weather monitoring system that I will then improve up to the point where it can be used where I indtend to. This project will be combined with another project of mine, the production of a cheap ultrasonic anemometer. I like to fly and having a good idea of the wind is crutial. However, anemometer are expensive and not fit for use in winter. Ultrasonic ones are better for use in harsh environement but they are ridiculously expensive, even if their operation is relatively simple. I do not intend to make some fancy app, pretty HW and all that bullshit. Just to make something to collect and visualise data in a simple and effective way. Everything will be public and open and I will gladly accept help from whoever will want to contribute. All in all if I end up with a thermometer in my bedroom that I can check from my phone I will bbe happy.","title":"Project goal"},{"location":"#project-motivation","text":"The motivation for this project is that there is no cheap environemental sensor that could survive the harsh winter we have where I live. This type of weather station is typicaly only used by governemental organisation or research center and they are too expensive / too large to be wide spread. Moreover, the data from these is not openly availiable.","title":"Project motivation"},{"location":"#project-timeline","text":"14/04/2020 - Official start of the project","title":"Project Timeline"},{"location":"#project-milestones","text":"","title":"Project milestones"},{"location":"#mark-i-city-system","text":"Produce a first prototype of node and server (breadboard mess type of thing). Produce integrated node for city use (semi-integrated in a custom PCB type of thing). MkI of the system completed (node, server, website).","title":"Mark I (city system)"},{"location":"#mark-ii-improved-for-harsh-winter-climate","text":"Create a autonomous power and life-support system for the node. Improved node HW / SW to work with new power and life-support. Node MkII completed (might also call it winter node) Survived one winter MkII of the system completed (node, server, website).","title":"Mark II (Improved for harsh winter climate)"},{"location":"#existing-similar-system","text":"Here is a totaly non exhaustive list of similar projects. All of them are intended for city usage.","title":"Existing similar system"},{"location":"#citizen-efforts","text":"Hackair Luftdaten (Very similar to what I try to do, exept I want a more modular system..) aircarto (Project seems frozen..) airboxlab Sensebox (sort of for profit still..)","title":"Citizen efforts"},{"location":"#for-profit","text":"Air things HabitatMap openAQ","title":"For profit"},{"location":"docs-info/","text":"Docs information On this page some information is provided how to operate the docs. For complete information see: https://www.mkdocs.org/user-guide/writing-your-docs/ Tip It is possible to create pages and edit the configuration from GitLab directly BUT it is much more convenient to run it locally in case of problems. This can be done by cloning the repository: git clone https://gitlab.cern.ch/be-bi-bgi/bgi-documentation.git && cd bgi-documentation To run locally you need to install MkDocs and the theme. In case of problems check your Python version python --version . It has been tested and working on MacOS 10.15.1 using Python 3.7.4. pip install mkdocs mkdocs-material Now you can hopefully start MkDocs and see the website at http://127.0.0.1:8000/ using the command below (see https://www.mkdocs.org/#getting-started for more info). mkdocs serve As soon as you edit a page or the config file, the website will reload. If there are any errors it might not reload and you need to check the output in the terminal. When you are done, commit the changes and push to the repository ( Git instructions ) The public website will reload automatically after a minute or two. Creating new pages Creating a new page involves two steps. Create the .md file in the correct directory Update the mkdocs.yml file Directory Structure The directory structure should be kept the same as the structure of the website. | -electronics | ---detector | ---readout | -mechanics | -physics | -software | ---analysis | ---lab-debug | ---operational Example The important section of the mkdocs.yml file is under nav . Indentation level sets the structure of the pages. This should match the directory structure. A snippet of the file can be seen below: nav : - Home : - Welcome : index.md - Docs information : docs-info.md - Software : - Overview : software/overview.md - Lab & Debug : - Panda GUI : software/lab-debug/panda-gui.md Create a Markdown page from a Jupyter notebook This will include figures and tables from the compiled notebook. More info at: https://predictablynoisy.com/jekyll-markdown-nbconvert Snippet !jupyter nbconvert --to markdown --output-dir = 'OUTPUT_DIRECTORY' NAME_OF_THE_NOTEBOOK.ipynb Extending the default template See: https://nbconvert.readthedocs.io/en/latest/customizing.html#Custom-Templates","title":"Docs Information"},{"location":"docs-info/#docs-information","text":"On this page some information is provided how to operate the docs. For complete information see: https://www.mkdocs.org/user-guide/writing-your-docs/ Tip It is possible to create pages and edit the configuration from GitLab directly BUT it is much more convenient to run it locally in case of problems. This can be done by cloning the repository: git clone https://gitlab.cern.ch/be-bi-bgi/bgi-documentation.git && cd bgi-documentation To run locally you need to install MkDocs and the theme. In case of problems check your Python version python --version . It has been tested and working on MacOS 10.15.1 using Python 3.7.4. pip install mkdocs mkdocs-material Now you can hopefully start MkDocs and see the website at http://127.0.0.1:8000/ using the command below (see https://www.mkdocs.org/#getting-started for more info). mkdocs serve As soon as you edit a page or the config file, the website will reload. If there are any errors it might not reload and you need to check the output in the terminal. When you are done, commit the changes and push to the repository ( Git instructions ) The public website will reload automatically after a minute or two.","title":"Docs information"},{"location":"docs-info/#creating-new-pages","text":"Creating a new page involves two steps. Create the .md file in the correct directory Update the mkdocs.yml file Directory Structure The directory structure should be kept the same as the structure of the website. | -electronics | ---detector | ---readout | -mechanics | -physics | -software | ---analysis | ---lab-debug | ---operational Example The important section of the mkdocs.yml file is under nav . Indentation level sets the structure of the pages. This should match the directory structure. A snippet of the file can be seen below: nav : - Home : - Welcome : index.md - Docs information : docs-info.md - Software : - Overview : software/overview.md - Lab & Debug : - Panda GUI : software/lab-debug/panda-gui.md","title":"Creating new pages"},{"location":"docs-info/#create-a-markdown-page-from-a-jupyter-notebook","text":"This will include figures and tables from the compiled notebook. More info at: https://predictablynoisy.com/jekyll-markdown-nbconvert Snippet !jupyter nbconvert --to markdown --output-dir = 'OUTPUT_DIRECTORY' NAME_OF_THE_NOTEBOOK.ipynb","title":"Create a Markdown page from a Jupyter notebook"},{"location":"docs-info/#extending-the-default-template","text":"See: https://nbconvert.readthedocs.io/en/latest/customizing.html#Custom-Templates","title":"Extending the default template"},{"location":"example-markdown/","text":"Example Markdown This page shows some example markdown code Cheat sheet https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Links External link example [LINK TEXT <i class= \"fa fa-external-link\" ></i> ](LINK-URL){target=\"\\_blank\"} LINK TEXT Images Image Example Inline - style : ! [ alt text ]( http : //via.placeholder.com/100x100 \"Title Text 1\") Reference - style : ! [ alt text ][ logo ] [ logo ] : http : //via.placeholder.com/100x100 \"Title Text 2\" Inline-style: Reference-style: Image with size constraint, e.g. 50% width ![ALT TEXT GOES HERE](http://via.placeholder.com/600x100){style=\"width:50%\"} Clickable image with figure text [![ALT TEXT GOES HERE](http://via.placeholder.com/600x100){style=\"width:50%\"}](http://via.placeholder.com/600x100) <p style= \"text-align: center;\" > **Figure N:** Centered figure text. </p> Figure N: Centered figure text. Admonition https://squidfunk.github.io/mkdocs-material/extensions/admonition/ !!! note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! abstract Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! success Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Abstract Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Success Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. PyMdown https://squidfunk.github.io/mkdocs-material/extensions/pymdown/ Arithmatex Show LaTeX style math. Arithmatex Example $$ \\ frac { n ! }{ k ! ( n - k ) ! } = \\ binom { n }{ k } $$ Lorem ipsum dolor sit amet : $ p ( x | y ) = \\ frac { p ( y | x ) p ( x ) }{ p ( y ) }$ \\frac{n!}{k!(n-k)!} = \\binom{n}{k} \\frac{n!}{k!(n-k)!} = \\binom{n}{k} Lorem ipsum dolor sit amet: p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} Mark Mark Example Used to ==highlight== text. Used to highlight text. Tasklist Tasklist Example * [ x ] Lorem ipsum dolor sit amet , consectetur adipiscing elit * [ ] Vestibulum convallis sit amet nisi a tincidunt * [ x ] Sed egestas felis quis elit dapibus , ac aliquet turpis mattis * [ ] Praesent sed risus massa * [ ] Nulla vel eros venenatis , imperdiet enim id , faucibus nisi Lorem ipsum dolor sit amet, consectetur adipiscing elit Vestibulum convallis sit amet nisi a tincidunt Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Nulla vel eros venenatis, imperdiet enim id, faucibus nisi ProgressBar Progress Bar Example [=0% \"0%\"] [=5% \"5%\"] [=25% \"25%\"] [=45% \"45%\"] [=65% \"65%\"] [=85% \"85%\"] [=100% \"100%\"] 0% 5% 25% 45% 65% 85% 100% Font Awesome http://bwmarrin.github.io/MkDocsPlus/fontawesome/ https://astronautweb.co/snippet/font-awesome/ fa-lg fa-2x fa-3x fa-4x fa-5x","title":"Example Markdown"},{"location":"example-markdown/#example-markdown","text":"This page shows some example markdown code","title":"Example Markdown"},{"location":"example-markdown/#cheat-sheet","text":"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet","title":"Cheat sheet"},{"location":"example-markdown/#links","text":"External link example [LINK TEXT <i class= \"fa fa-external-link\" ></i> ](LINK-URL){target=\"\\_blank\"} LINK TEXT","title":"Links"},{"location":"example-markdown/#images","text":"Image Example Inline - style : ! [ alt text ]( http : //via.placeholder.com/100x100 \"Title Text 1\") Reference - style : ! [ alt text ][ logo ] [ logo ] : http : //via.placeholder.com/100x100 \"Title Text 2\" Inline-style: Reference-style: Image with size constraint, e.g. 50% width ![ALT TEXT GOES HERE](http://via.placeholder.com/600x100){style=\"width:50%\"} Clickable image with figure text [![ALT TEXT GOES HERE](http://via.placeholder.com/600x100){style=\"width:50%\"}](http://via.placeholder.com/600x100) <p style= \"text-align: center;\" > **Figure N:** Centered figure text. </p> Figure N: Centered figure text.","title":"Images"},{"location":"example-markdown/#admonition","text":"https://squidfunk.github.io/mkdocs-material/extensions/admonition/ !!! note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! abstract Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! success Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. !!! danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Abstract Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Success Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod. Danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod.","title":"Admonition"},{"location":"example-markdown/#pymdown","text":"https://squidfunk.github.io/mkdocs-material/extensions/pymdown/","title":"PyMdown"},{"location":"example-markdown/#arithmatex","text":"Show LaTeX style math. Arithmatex Example $$ \\ frac { n ! }{ k ! ( n - k ) ! } = \\ binom { n }{ k } $$ Lorem ipsum dolor sit amet : $ p ( x | y ) = \\ frac { p ( y | x ) p ( x ) }{ p ( y ) }$ \\frac{n!}{k!(n-k)!} = \\binom{n}{k} \\frac{n!}{k!(n-k)!} = \\binom{n}{k} Lorem ipsum dolor sit amet: p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)}","title":"Arithmatex"},{"location":"example-markdown/#mark","text":"Mark Example Used to ==highlight== text. Used to highlight text.","title":"Mark"},{"location":"example-markdown/#tasklist","text":"Tasklist Example * [ x ] Lorem ipsum dolor sit amet , consectetur adipiscing elit * [ ] Vestibulum convallis sit amet nisi a tincidunt * [ x ] Sed egestas felis quis elit dapibus , ac aliquet turpis mattis * [ ] Praesent sed risus massa * [ ] Nulla vel eros venenatis , imperdiet enim id , faucibus nisi Lorem ipsum dolor sit amet, consectetur adipiscing elit Vestibulum convallis sit amet nisi a tincidunt Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Nulla vel eros venenatis, imperdiet enim id, faucibus nisi","title":"Tasklist"},{"location":"example-markdown/#progressbar","text":"Progress Bar Example [=0% \"0%\"] [=5% \"5%\"] [=25% \"25%\"] [=45% \"45%\"] [=65% \"65%\"] [=85% \"85%\"] [=100% \"100%\"] 0% 5% 25% 45% 65% 85% 100%","title":"ProgressBar"},{"location":"example-markdown/#font-awesome","text":"http://bwmarrin.github.io/MkDocsPlus/fontawesome/ https://astronautweb.co/snippet/font-awesome/ fa-lg fa-2x fa-3x fa-4x fa-5x","title":"Font Awesome"},{"location":"node/city-node-error-state/","text":"Error state Implementation","title":"Error state"},{"location":"node/city-node-error-state/#error-state","text":"","title":"Error state"},{"location":"node/city-node-error-state/#implementation","text":"","title":"Implementation"},{"location":"node/city-node-fsm-implementation/","text":"Finite state machine implementation Sources I have pretty much stolen the structure of the FSM from this example. Things were well explained and I could apply it to my project quickly. Implementation Warning This is in no way a tutorial or something intended for people to reproduce this project. It iss only here for me to remember how I did things. Disclaimer I could have done it in a much simpler way since, so far, all opperation are pretty much sequential. Thus I do not need a finite state machine to run the system. However, I will use this code as a base to expend on the system and it is quite sure that the complexity of things will increase. Moreover, I have never implemented a FSM in OOP style before and I thought this was a good opportunity. (This is why I implemented this OOP state machine). Overview The FSM is a class which instanciate a new state object at each state transition. Each state object inherit from a generic state obbject. There are five files in total. GenericState class This class is a generic state used to create each state object. Contained in a single file GenericState.h The code: #pragma once #include \"FiniteStateMachine.h\" // Abstract state class // Forward declaration to resolve circular dependency/include class FiniteStateMachine ; class GenericState { public : virtual void enter ( FiniteStateMachine * fsm ) = 0 ; virtual void toggle ( FiniteStateMachine * fsm ) = 0 ; virtual void exit ( FiniteStateMachine * fsm ) = 0 ; virtual ~ GenericState () {} }; The enter method is here to do things when we enter the state. This is pretty much where all the work will go. The toggle method is here to change state. it is called once we are done working in this state. The exit method is here to do things after we changed state. I don't see a use for it now.. Perhaps some cleaning when needed. SystemStates classes These files SystemStates.h / SystemStates.cpp contain the implementation of each state. Depending how busy each state will become, I might move them to their own files. SystemStates.h: #pragma once #include \"GenericState.h\" #include \"FiniteStateMachine.h\" #include <Arduino.h> #include <HardwareSerial.h> class Initialise : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 0 ; private : Initialise () {} Initialise ( const Initialise & other ); Initialise & operator = ( const Initialise & other ); }; class Sleep : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 1 ; private : Sleep () {} Sleep ( const Sleep & other ); Sleep & operator = ( const Sleep & other ); }; class Measure : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 2 ; private : Measure () {} Measure ( const Measure & other ); Measure & operator = ( const Measure & other ); }; class Transmit : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 3 ; private : Transmit () {} Transmit ( const Transmit & other ); Transmit & operator = ( const Transmit & other ); }; class Save : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 4 ; private : Save () {} Save ( const Save & other ); Save & operator = ( const Save & other ); }; class Error : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 5 ; private : Error () {} Error ( const Error & other ); Error & operator = ( const Error & other ); }; I do not know why there is so many constructors (3/class). But I do not care, it works. SystemStates.cpp: #include \"SystemStates.h\" //============================================================================== // Initialise State //============================================================================== void Initialise :: toggle ( FiniteStateMachine * fsm ) { // change state from init to sleep // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Sleep :: getInstance ()); } GenericState & Initialise :: getInstance () { static Initialise singleton ; return singleton ; } void Initialise :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered Init state\" ); delay ( 2000 ); } //============================================================================== // Sleep State //============================================================================== void Sleep :: toggle ( FiniteStateMachine * fsm ) { // change state from sleep to measure // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Measure :: getInstance ()); } GenericState & Sleep :: getInstance () { static Sleep singleton ; return singleton ; } void Sleep :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered Sleep state\" ); delay ( 2000 ); //LowPower.sleep(4000); DOES NOT WORK } //============================================================================== // Measure State //============================================================================== void Measure :: toggle ( FiniteStateMachine * fsm ) { // change state from measure to transmit // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Transmit :: getInstance ()); } GenericState & Measure :: getInstance () { static Measure singleton ; return singleton ; } void Measure :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered measure state\" ); delay ( 500 ); } //============================================================================== // Transmit State //============================================================================== void Transmit :: toggle ( FiniteStateMachine * fsm ) { // change state from transmit to save // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Save :: getInstance ()); } GenericState & Transmit :: getInstance () { static Transmit singleton ; return singleton ; } void Transmit :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered transmit state\" ); delay ( 500 ); } //============================================================================== // Save State //============================================================================== void Save :: toggle ( FiniteStateMachine * fsm ) { // change state from Save to sleep // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Sleep :: getInstance ()); } GenericState & Save :: getInstance () { static Save singleton ; return singleton ; } void Save :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered Save state\" ); delay ( 500 ); } //============================================================================== // Error State //============================================================================== void Error :: toggle ( FiniteStateMachine * fsm ) { // change state from Save to sleep // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Initialise :: getInstance ()); } GenericState & Error :: getInstance () { static Error singleton ; return singleton ; } void Error :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered error state\" ); delay ( 500 ); } This is just the squeleton, none of the actual work is perfomed in these class at the moment. The toggle method changes the state of the FinitStateMachine object it was instanciated into to the next state. It does so by passing a singleton of the next state class. There we can add more decision making later.. For now the transition is braindead. The getInstance method instanciate a singleton of the state class and rerurns it. The enter method is filled with debug code. FiniteStateMachine class This class is the FSM and it glues all the state class together. It has two files FiniteStateMachine.cpp and FiniteStateMachine.h . FiniteStateMachine.h: #pragma once #include \"GenericState.h\" class GenericState ; class FiniteStateMachine { public : // Constructor, init the state machine FiniteStateMachine (); // toggle the state machine void toggle (); // inline function to get the current state of the FSM inline GenericState * getCurrentState () const { return currentState ; } // Set the FSM state void setState ( GenericState & newState ); private : // the fsm state GenericState * currentState ; }; FiniteStateMachine.cpp: #include \"FiniteStateMachine.h\" #include \"SystemStates.h\" FiniteStateMachine :: FiniteStateMachine () { // All the system starts in the init state currentState = & Initialise :: getInstance (); } void FiniteStateMachine :: setState ( GenericState & newState ) { currentState -> exit ( this ); // do stuff before we change state currentState = & newState ; currentState -> enter ( this ); // do stuff after we change state } // ask the current state to change state void FiniteStateMachine :: toggle () { // Delegate the task of determining the next state to the current state currentState -> toggle ( this ); } The constructor set the current state to the initialise state. The setState method calls the exit method of the current state, changes the state to the next one (which is passed as an argument by the previous state) and calls the enter method of the state we just entered. The toggle method is here to manualy request for the next state, it is used for debug. We will most probably not need it later as, I guess, the state will call its toggle method y itself when it is done working (at the end of its enter method). Test code This is the code I used to test the good function of the FSM. It just instanciates the FSM object, open a serial connection to my pc and toggle the states. #include \"FiniteStateMachine.h\" int delayValue = 2000 ; FiniteStateMachine f void setup () { // initialize serial communication at 9600 bits per second: Serial . begin ( 9600 ); Serial . println ( \"start test\" ); delay ( delayValue ); void loop () { // run the fsm forever fsm . toggle (); } This yeild the folowing serial print. 14 : 13 : 30.527 -> entered Sleep state 14 : 13 : 32.504 -> entered measure state 14 : 13 : 33.035 -> entered transmit state 14 : 13 : 33.519 -> entered Save state 14 : 13 : 34.011 -> entered Sleep state 14 : 13 : 36.015 -> entered measure state 14 : 13 : 36.502 -> entered transmit state 14 : 13 : 37.022 -> entered Save state 14 : 13 : 37.514 -> entered Sleep state * The \"init state\" and \"start test\" messages are not displayed since it takes some time for the serial monitor to start. I am sure there is some way to fix that but I do not really care...","title":"State machine implementation"},{"location":"node/city-node-fsm-implementation/#finite-state-machine-implementation","text":"","title":"Finite state machine implementation"},{"location":"node/city-node-fsm-implementation/#sources","text":"I have pretty much stolen the structure of the FSM from this example. Things were well explained and I could apply it to my project quickly.","title":"Sources"},{"location":"node/city-node-fsm-implementation/#implementation","text":"Warning This is in no way a tutorial or something intended for people to reproduce this project. It iss only here for me to remember how I did things.","title":"Implementation"},{"location":"node/city-node-fsm-implementation/#disclaimer","text":"I could have done it in a much simpler way since, so far, all opperation are pretty much sequential. Thus I do not need a finite state machine to run the system. However, I will use this code as a base to expend on the system and it is quite sure that the complexity of things will increase. Moreover, I have never implemented a FSM in OOP style before and I thought this was a good opportunity. (This is why I implemented this OOP state machine).","title":"Disclaimer"},{"location":"node/city-node-fsm-implementation/#overview","text":"The FSM is a class which instanciate a new state object at each state transition. Each state object inherit from a generic state obbject. There are five files in total.","title":"Overview"},{"location":"node/city-node-fsm-implementation/#genericstate-class","text":"This class is a generic state used to create each state object. Contained in a single file GenericState.h The code: #pragma once #include \"FiniteStateMachine.h\" // Abstract state class // Forward declaration to resolve circular dependency/include class FiniteStateMachine ; class GenericState { public : virtual void enter ( FiniteStateMachine * fsm ) = 0 ; virtual void toggle ( FiniteStateMachine * fsm ) = 0 ; virtual void exit ( FiniteStateMachine * fsm ) = 0 ; virtual ~ GenericState () {} }; The enter method is here to do things when we enter the state. This is pretty much where all the work will go. The toggle method is here to change state. it is called once we are done working in this state. The exit method is here to do things after we changed state. I don't see a use for it now.. Perhaps some cleaning when needed.","title":"GenericState class"},{"location":"node/city-node-fsm-implementation/#systemstates-classes","text":"These files SystemStates.h / SystemStates.cpp contain the implementation of each state. Depending how busy each state will become, I might move them to their own files. SystemStates.h: #pragma once #include \"GenericState.h\" #include \"FiniteStateMachine.h\" #include <Arduino.h> #include <HardwareSerial.h> class Initialise : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 0 ; private : Initialise () {} Initialise ( const Initialise & other ); Initialise & operator = ( const Initialise & other ); }; class Sleep : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 1 ; private : Sleep () {} Sleep ( const Sleep & other ); Sleep & operator = ( const Sleep & other ); }; class Measure : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 2 ; private : Measure () {} Measure ( const Measure & other ); Measure & operator = ( const Measure & other ); }; class Transmit : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 3 ; private : Transmit () {} Transmit ( const Transmit & other ); Transmit & operator = ( const Transmit & other ); }; class Save : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 4 ; private : Save () {} Save ( const Save & other ); Save & operator = ( const Save & other ); }; class Error : public GenericState { public : void enter ( FiniteStateMachine * fsm ); void toggle ( FiniteStateMachine * fsm ); void exit ( FiniteStateMachine * fsm ) {} static GenericState & getInstance (); int stateNumber = 5 ; private : Error () {} Error ( const Error & other ); Error & operator = ( const Error & other ); }; I do not know why there is so many constructors (3/class). But I do not care, it works. SystemStates.cpp: #include \"SystemStates.h\" //============================================================================== // Initialise State //============================================================================== void Initialise :: toggle ( FiniteStateMachine * fsm ) { // change state from init to sleep // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Sleep :: getInstance ()); } GenericState & Initialise :: getInstance () { static Initialise singleton ; return singleton ; } void Initialise :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered Init state\" ); delay ( 2000 ); } //============================================================================== // Sleep State //============================================================================== void Sleep :: toggle ( FiniteStateMachine * fsm ) { // change state from sleep to measure // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Measure :: getInstance ()); } GenericState & Sleep :: getInstance () { static Sleep singleton ; return singleton ; } void Sleep :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered Sleep state\" ); delay ( 2000 ); //LowPower.sleep(4000); DOES NOT WORK } //============================================================================== // Measure State //============================================================================== void Measure :: toggle ( FiniteStateMachine * fsm ) { // change state from measure to transmit // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Transmit :: getInstance ()); } GenericState & Measure :: getInstance () { static Measure singleton ; return singleton ; } void Measure :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered measure state\" ); delay ( 500 ); } //============================================================================== // Transmit State //============================================================================== void Transmit :: toggle ( FiniteStateMachine * fsm ) { // change state from transmit to save // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Save :: getInstance ()); } GenericState & Transmit :: getInstance () { static Transmit singleton ; return singleton ; } void Transmit :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered transmit state\" ); delay ( 500 ); } //============================================================================== // Save State //============================================================================== void Save :: toggle ( FiniteStateMachine * fsm ) { // change state from Save to sleep // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Sleep :: getInstance ()); } GenericState & Save :: getInstance () { static Save singleton ; return singleton ; } void Save :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered Save state\" ); delay ( 500 ); } //============================================================================== // Error State //============================================================================== void Error :: toggle ( FiniteStateMachine * fsm ) { // change state from Save to sleep // for now I'll ignore the error state // use the fsm object we passed to create an instance of the next state. fsm -> setState ( Initialise :: getInstance ()); } GenericState & Error :: getInstance () { static Error singleton ; return singleton ; } void Error :: enter ( FiniteStateMachine * fsm ) { Serial . println ( \"entered error state\" ); delay ( 500 ); } This is just the squeleton, none of the actual work is perfomed in these class at the moment. The toggle method changes the state of the FinitStateMachine object it was instanciated into to the next state. It does so by passing a singleton of the next state class. There we can add more decision making later.. For now the transition is braindead. The getInstance method instanciate a singleton of the state class and rerurns it. The enter method is filled with debug code.","title":"SystemStates classes"},{"location":"node/city-node-fsm-implementation/#finitestatemachine-class","text":"This class is the FSM and it glues all the state class together. It has two files FiniteStateMachine.cpp and FiniteStateMachine.h . FiniteStateMachine.h: #pragma once #include \"GenericState.h\" class GenericState ; class FiniteStateMachine { public : // Constructor, init the state machine FiniteStateMachine (); // toggle the state machine void toggle (); // inline function to get the current state of the FSM inline GenericState * getCurrentState () const { return currentState ; } // Set the FSM state void setState ( GenericState & newState ); private : // the fsm state GenericState * currentState ; }; FiniteStateMachine.cpp: #include \"FiniteStateMachine.h\" #include \"SystemStates.h\" FiniteStateMachine :: FiniteStateMachine () { // All the system starts in the init state currentState = & Initialise :: getInstance (); } void FiniteStateMachine :: setState ( GenericState & newState ) { currentState -> exit ( this ); // do stuff before we change state currentState = & newState ; currentState -> enter ( this ); // do stuff after we change state } // ask the current state to change state void FiniteStateMachine :: toggle () { // Delegate the task of determining the next state to the current state currentState -> toggle ( this ); } The constructor set the current state to the initialise state. The setState method calls the exit method of the current state, changes the state to the next one (which is passed as an argument by the previous state) and calls the enter method of the state we just entered. The toggle method is here to manualy request for the next state, it is used for debug. We will most probably not need it later as, I guess, the state will call its toggle method y itself when it is done working (at the end of its enter method).","title":"FiniteStateMachine class"},{"location":"node/city-node-fsm-implementation/#test-code","text":"This is the code I used to test the good function of the FSM. It just instanciates the FSM object, open a serial connection to my pc and toggle the states. #include \"FiniteStateMachine.h\" int delayValue = 2000 ; FiniteStateMachine f void setup () { // initialize serial communication at 9600 bits per second: Serial . begin ( 9600 ); Serial . println ( \"start test\" ); delay ( delayValue ); void loop () { // run the fsm forever fsm . toggle (); } This yeild the folowing serial print. 14 : 13 : 30.527 -> entered Sleep state 14 : 13 : 32.504 -> entered measure state 14 : 13 : 33.035 -> entered transmit state 14 : 13 : 33.519 -> entered Save state 14 : 13 : 34.011 -> entered Sleep state 14 : 13 : 36.015 -> entered measure state 14 : 13 : 36.502 -> entered transmit state 14 : 13 : 37.022 -> entered Save state 14 : 13 : 37.514 -> entered Sleep state * The \"init state\" and \"start test\" messages are not displayed since it takes some time for the serial monitor to start. I am sure there is some way to fix that but I do not really care...","title":"Test code"},{"location":"node/city-node-hardware/","text":"Node Hardware Prototyping In order to develop the node firmware and server software I used a breadoard prototype. It is comprised of: Arduino nano IOT (see bellow) Some sensors (selected based on other similar projects.) BME680 CCS811 SDS011 A SD card module + 16GB SD card The sd card might be quite overkill but well it was cheap and I had no idea how much data I would need to store when I ordered... A GPS module (GY-NEO6MV2) Used for position measurement in a mobile system. Used for clock synchronisation in absence of internet access. A small oled screen. Used for debug and for user interface. Not strictly required from the requirements but I though it would be nice to see the measurement in real time. A RTC module. This was a it of a mistake since I forgot I could get the clock from the GPS... MCUs I have three MCU for this prototype. The reason is that I had a arduino nano on my desk. However, I want to make this into a cheap system and the arduino is FAR from cheap. Thus I went for a NodeMCU(ESP8266), which is quite a lot cheaper for similar specs. I also got its younger brother the ESP-WROOM-32 , a bit more expensive but with far more computation power + embedded bluetooth. I will start with the arduino and switch to the other when they get here... I would also like to try a few diferent MCU to see which hold best against cold temperature. Arduinot nano IOT It is an arduino :) . SAMD21 Cortex\u00ae-M0+ 32bit low power ARM MCU Datasheet RF: u-blox NINA-W102 Datasheet IMU: LSM6DS3 Datasheet Crypto: ATECC608A Datasheet NodeMCU V3 It not an arduino :) . ESP8266 does it all. Datasheet ESP-WROOM-32 Datasheet Sensors BME680 Primary sensor of the system. This guy could be replaced by a BME280 to cut cost (if the air quality measurement is deamed useless). Sense: Index of air quality (IAQ) from 0 to 500. (If I find some code to compute it...) Temperature from -40 \u00b0C to 86 \u00b0C \u00b11 \u00b0C. Pressure from 300 to 1100 hPa \u00b10.6 hPa. humidity from 0 to 100 %r.H \u00b13 %r.H. Valid for 0\u00b0C to 65\u00b0C. Datasheet CCS811 Sense: equivalent CO2 (eCO2) from 400ppm up to 29206ppm. equivalent Total Volatile Organic Compound (eTVOC) from 0ppb up to 32768ppb. Can include a temperature and humidity compensation. Datasheet SDS011 Particulate matter sensor. Sense: PM2.5 and PM10 from 0.0-999.9 \u03bcg/m3 Unreliable for RH > 80% \u2192 paper Datasheet BOM In hindsight I totaly got ripped-off for the shipping of the RTC module. (I noticed it when doing this doc.) The total might be a bit off I rounded some values. Part Name Type Unit Price (\u20ac) Shipping cost (\u20ac) Merchant Arduino nano IOT MCU 18 + 4.15 5.5 arduino store NodeMcu V3 MCU 1.92 0.6 aliexpress ESP-WROOM-32 MCU 3.5 2 aliexpress WAVGAT GY-NEO6MV2 GPS module 2.92 0.5 aliexpress WAVGAT Micro-SD card SD card module 0.36 0.5 aliexpress DS3231 AT24C32 IIC RTC module 0.92 4 aliexpress Nova PM SDS011 PM sensor 17.38 0 aliexpress BME680 TPH + gas sensor 7.84 2 aliexpress CCS811 tcov/eCO2 sensor 5.27 2 aliexpress SanDisk A1 16GB 16GB SD card 3.5 1 aliexpress 0.96\" oled screen oled screen 1.6 0.9 aliexpress USB charger 10W USB charger 0.96 0.7 aliexpress Total 67.86 19.2","title":"Hardware overview"},{"location":"node/city-node-hardware/#node-hardware","text":"","title":"Node Hardware"},{"location":"node/city-node-hardware/#prototyping","text":"In order to develop the node firmware and server software I used a breadoard prototype. It is comprised of: Arduino nano IOT (see bellow) Some sensors (selected based on other similar projects.) BME680 CCS811 SDS011 A SD card module + 16GB SD card The sd card might be quite overkill but well it was cheap and I had no idea how much data I would need to store when I ordered... A GPS module (GY-NEO6MV2) Used for position measurement in a mobile system. Used for clock synchronisation in absence of internet access. A small oled screen. Used for debug and for user interface. Not strictly required from the requirements but I though it would be nice to see the measurement in real time. A RTC module. This was a it of a mistake since I forgot I could get the clock from the GPS...","title":"Prototyping"},{"location":"node/city-node-hardware/#mcus","text":"I have three MCU for this prototype. The reason is that I had a arduino nano on my desk. However, I want to make this into a cheap system and the arduino is FAR from cheap. Thus I went for a NodeMCU(ESP8266), which is quite a lot cheaper for similar specs. I also got its younger brother the ESP-WROOM-32 , a bit more expensive but with far more computation power + embedded bluetooth. I will start with the arduino and switch to the other when they get here... I would also like to try a few diferent MCU to see which hold best against cold temperature.","title":"MCUs"},{"location":"node/city-node-hardware/#arduinot-nano-iot","text":"It is an arduino :) . SAMD21 Cortex\u00ae-M0+ 32bit low power ARM MCU Datasheet RF: u-blox NINA-W102 Datasheet IMU: LSM6DS3 Datasheet Crypto: ATECC608A Datasheet","title":"Arduinot nano IOT"},{"location":"node/city-node-hardware/#nodemcu-v3","text":"It not an arduino :) . ESP8266 does it all. Datasheet","title":"NodeMCU V3"},{"location":"node/city-node-hardware/#esp-wroom-32","text":"Datasheet","title":"ESP-WROOM-32"},{"location":"node/city-node-hardware/#sensors","text":"","title":"Sensors"},{"location":"node/city-node-hardware/#bme680","text":"Primary sensor of the system. This guy could be replaced by a BME280 to cut cost (if the air quality measurement is deamed useless). Sense: Index of air quality (IAQ) from 0 to 500. (If I find some code to compute it...) Temperature from -40 \u00b0C to 86 \u00b0C \u00b11 \u00b0C. Pressure from 300 to 1100 hPa \u00b10.6 hPa. humidity from 0 to 100 %r.H \u00b13 %r.H. Valid for 0\u00b0C to 65\u00b0C. Datasheet","title":"BME680"},{"location":"node/city-node-hardware/#ccs811","text":"Sense: equivalent CO2 (eCO2) from 400ppm up to 29206ppm. equivalent Total Volatile Organic Compound (eTVOC) from 0ppb up to 32768ppb. Can include a temperature and humidity compensation. Datasheet","title":"CCS811"},{"location":"node/city-node-hardware/#sds011","text":"Particulate matter sensor. Sense: PM2.5 and PM10 from 0.0-999.9 \u03bcg/m3 Unreliable for RH > 80% \u2192 paper Datasheet","title":"SDS011"},{"location":"node/city-node-hardware/#bom","text":"In hindsight I totaly got ripped-off for the shipping of the RTC module. (I noticed it when doing this doc.) The total might be a bit off I rounded some values. Part Name Type Unit Price (\u20ac) Shipping cost (\u20ac) Merchant Arduino nano IOT MCU 18 + 4.15 5.5 arduino store NodeMcu V3 MCU 1.92 0.6 aliexpress ESP-WROOM-32 MCU 3.5 2 aliexpress WAVGAT GY-NEO6MV2 GPS module 2.92 0.5 aliexpress WAVGAT Micro-SD card SD card module 0.36 0.5 aliexpress DS3231 AT24C32 IIC RTC module 0.92 4 aliexpress Nova PM SDS011 PM sensor 17.38 0 aliexpress BME680 TPH + gas sensor 7.84 2 aliexpress CCS811 tcov/eCO2 sensor 5.27 2 aliexpress SanDisk A1 16GB 16GB SD card 3.5 1 aliexpress 0.96\" oled screen oled screen 1.6 0.9 aliexpress USB charger 10W USB charger 0.96 0.7 aliexpress Total 67.86 19.2","title":"BOM"},{"location":"node/city-node-init-state/","text":"Init state Implementation","title":"Init state"},{"location":"node/city-node-init-state/#init-state","text":"","title":"Init state"},{"location":"node/city-node-init-state/#implementation","text":"","title":"Implementation"},{"location":"node/city-node-measure-state/","text":"Measure state Implementation","title":"Measure state"},{"location":"node/city-node-measure-state/#measure-state","text":"","title":"Measure state"},{"location":"node/city-node-measure-state/#implementation","text":"","title":"Implementation"},{"location":"node/city-node-requirement-specs/","text":"Node Requirement and Specifications These are given as a best effort based requirements. I will try to meet these but I will not stop the project if I fail to meet some. The concept of a node is defined as a simple \"smart\" environemental sensor. The node is connected to the server via a network (ethernet, bluetooth, LoRa..) to transmit its measurements. In case of total or transcient absence of network connectivity, the measurements are logged onboard the node for later retransmition or manual recovery. It can be either power autonomous (portable / remote area) or power dependant (places were power can be provided). To guaranty a wide spread deployement, the node shall be as cheap as possible, while maintaining a somewhat reliable system (no janky HW recup). The end goal is to have an autonomous sensor that can be used in hard environement (e.g. high montain). Measurement types The idea is to have a basic node that provide base measurements and a large panel of aditional measurements types to fit most users need. All measurements shall be timestamped (localy with GPS time standard). Base measurements The node shall measure the folowing environemental parameters: Air temperature in Kelvin (K) Air pressure in Pascal (Pa) Relative humidity in % Air measurements wind speed wind direction Particulate mater concentration in air PM2.5 (2.5 um and smaller) PM10 (10 um and smaller) Total volatile organic compound (Tvoc) Carbon dioxide (CO2) Ozone (O3) nitrogen dioxide (NO2) Caron monoxide (CO) Other gasses such as propane, butane etc... (for a potential kitchen monitoring system..) Radon Cosmic measurements cosmic muons ? (just for fun) Ground measurements Ground temperature Ground humidity Mechanical & environemental MkI The size of the basic city node shall be within 90 x 60 x 30 mm3 (bit bigger than a RPi4 ) The node shall be IP53 compliant Somewhat Dust tight Rain proof Mild shock/impact resistance (in case of accidental fall). Operational temperature range -20C to +60C. Operational rel humidity 0% to 85%. Not suited for marine environement Mild UV resistance MkII Maximum size 200 x 200 x 200 mm3 IP67 compliant Dust tight Water tight Proper shock/impact resistance (in case of accidental fall in the montain). Ice proof Operational temperature range -40C to +60C. Operational rel humidity 0% to 85%. Altitude up to 5km Potential use close to shore Strong UV resistance Operational MkI Polling period 1 to 1440 min (24h) Low power in between measurements Power shall be provided from USB or other low voltage sources. A battery powered version shall work for 1yr continuously. All measurements are timestamped Capacity to keep track of time even in case of loss of power (RTC) Capacity to store up to 1yr of data onboard MKII Same as MKI plus: Battery powered for up to 3 months Solar powered System vitals are monitored along with the other environmental measurements User interface MkI On/off switch Some leds to give the state of the system Optional screen to give a live reading of the values Wake-up / force measurement push button (with a rate of max 0.1Hz) MkII on/off switch Some leds to give the state of the system Wake-up / force measurement push button (with a rate of max 0.1Hz)","title":"Requirements"},{"location":"node/city-node-requirement-specs/#node-requirement-and-specifications","text":"These are given as a best effort based requirements. I will try to meet these but I will not stop the project if I fail to meet some. The concept of a node is defined as a simple \"smart\" environemental sensor. The node is connected to the server via a network (ethernet, bluetooth, LoRa..) to transmit its measurements. In case of total or transcient absence of network connectivity, the measurements are logged onboard the node for later retransmition or manual recovery. It can be either power autonomous (portable / remote area) or power dependant (places were power can be provided). To guaranty a wide spread deployement, the node shall be as cheap as possible, while maintaining a somewhat reliable system (no janky HW recup). The end goal is to have an autonomous sensor that can be used in hard environement (e.g. high montain).","title":"Node Requirement and Specifications"},{"location":"node/city-node-requirement-specs/#measurement-types","text":"The idea is to have a basic node that provide base measurements and a large panel of aditional measurements types to fit most users need. All measurements shall be timestamped (localy with GPS time standard).","title":"Measurement types"},{"location":"node/city-node-requirement-specs/#base-measurements","text":"The node shall measure the folowing environemental parameters: Air temperature in Kelvin (K) Air pressure in Pascal (Pa) Relative humidity in %","title":"Base measurements"},{"location":"node/city-node-requirement-specs/#air-measurements","text":"wind speed wind direction Particulate mater concentration in air PM2.5 (2.5 um and smaller) PM10 (10 um and smaller) Total volatile organic compound (Tvoc) Carbon dioxide (CO2) Ozone (O3) nitrogen dioxide (NO2) Caron monoxide (CO) Other gasses such as propane, butane etc... (for a potential kitchen monitoring system..) Radon","title":"Air measurements"},{"location":"node/city-node-requirement-specs/#cosmic-measurements","text":"cosmic muons ? (just for fun)","title":"Cosmic measurements"},{"location":"node/city-node-requirement-specs/#ground-measurements","text":"Ground temperature Ground humidity","title":"Ground measurements"},{"location":"node/city-node-requirement-specs/#mechanical-environemental","text":"","title":"Mechanical &amp; environemental"},{"location":"node/city-node-requirement-specs/#mki","text":"The size of the basic city node shall be within 90 x 60 x 30 mm3 (bit bigger than a RPi4 ) The node shall be IP53 compliant Somewhat Dust tight Rain proof Mild shock/impact resistance (in case of accidental fall). Operational temperature range -20C to +60C. Operational rel humidity 0% to 85%. Not suited for marine environement Mild UV resistance","title":"MkI"},{"location":"node/city-node-requirement-specs/#mkii","text":"Maximum size 200 x 200 x 200 mm3 IP67 compliant Dust tight Water tight Proper shock/impact resistance (in case of accidental fall in the montain). Ice proof Operational temperature range -40C to +60C. Operational rel humidity 0% to 85%. Altitude up to 5km Potential use close to shore Strong UV resistance","title":"MkII"},{"location":"node/city-node-requirement-specs/#operational","text":"","title":"Operational"},{"location":"node/city-node-requirement-specs/#mki_1","text":"Polling period 1 to 1440 min (24h) Low power in between measurements Power shall be provided from USB or other low voltage sources. A battery powered version shall work for 1yr continuously. All measurements are timestamped Capacity to keep track of time even in case of loss of power (RTC) Capacity to store up to 1yr of data onboard","title":"MkI"},{"location":"node/city-node-requirement-specs/#mkii_1","text":"Same as MKI plus: Battery powered for up to 3 months Solar powered System vitals are monitored along with the other environmental measurements","title":"MKII"},{"location":"node/city-node-requirement-specs/#user-interface","text":"","title":"User interface"},{"location":"node/city-node-requirement-specs/#mki_2","text":"On/off switch Some leds to give the state of the system Optional screen to give a live reading of the values Wake-up / force measurement push button (with a rate of max 0.1Hz)","title":"MkI"},{"location":"node/city-node-requirement-specs/#mkii_2","text":"on/off switch Some leds to give the state of the system Wake-up / force measurement push button (with a rate of max 0.1Hz)","title":"MkII"},{"location":"node/city-node-save-state/","text":"Save state Implementation","title":"Save state"},{"location":"node/city-node-save-state/#save-state","text":"","title":"Save state"},{"location":"node/city-node-save-state/#implementation","text":"","title":"Implementation"},{"location":"node/city-node-sleep-state/","text":"Sleep state Implementation","title":"Sleep state"},{"location":"node/city-node-sleep-state/#sleep-state","text":"","title":"Sleep state"},{"location":"node/city-node-sleep-state/#implementation","text":"","title":"Implementation"},{"location":"node/city-node-software/","text":"Node Software Link to the project repo The node software is written in C++. The node is controled by a simple state machine (see bellow). In the current state of the system, there no real need for a state machine since all operations are pretty much sequential with minimum branching. MK1 State machine Figure 1: Simple node state machine. States description Init (state 0): The state in which we initialise the system after powering-up. Read the config file in the external memory (SD card) Configure the system based on the config file Set the wireless connection variable Set the time intervall for the measurements etc... If the file/sd-card is absent trigger a config-file error and go to the error state. Get the current time from a time server Turn off the things we do not need. e.g. the arduino nano iot has an IMU onboard, we do not need it. Sleep (state 1): The state in which we sleep until it is time to measure. (Pretty self explanatory). When entered: Set an RTC alarm to wake up for the next measurement. This will use the internal RTC and or the external one (not sure yet). I might rely on the internal one but also set the external one in case we loose power at some point and reset the system. This would allow to keep the measure at a consistent interval. Put the system into the lowest power mode imaginable. Not sure yet if I will wake-up put put to sleep everything here or not. I might also use the IMU to trigger extra measurements based on vibrartions This could be cool to detect small quake or rock slide. Measure (state 2): The state in which we perfom the enviromental measurements. We can also add some system state measurements. For each measurement: Turn-on the sensor. Wait some time to make sure the sensor is stable (can take several minutes). Get the measurement. Apply correction/calibration / do the computation needed to have the number we will transmit. Turn off the sensor. Some error handling: If problem, generate error code and or enter the error state. Transmit (state 3): The state in which we transmit the measured data to the server. Package the data to be transmited (to gain bandwith and time) This can be a simple \"squeeze\" things into a single word rather than have one per measurement. Will be defined later... Turn on the RF system (wifi, bluetooth, LoRa). Connect to the network. Get some network status data (RF signal strenght etc...). This add to the system status measurements. Connect to the server (Some sort of handshake would be nice). Transmit the data gathered in the previous state. (would be nice to have a transmition confirmation.) This include the environemental data and system status data. Turn off the RF. Save (state 4): The state in which we save the measured data to the external memory. Power up the SD card. Write the data to SD card with the .CSV format. This might change if I see that .CSV takes too much room. Power down the SD card. Error (state 5): The default state where we handle all systen breaking error detected by the system. TO BE COMPLETED","title":"Software overview"},{"location":"node/city-node-software/#node-software","text":"Link to the project repo The node software is written in C++. The node is controled by a simple state machine (see bellow). In the current state of the system, there no real need for a state machine since all operations are pretty much sequential with minimum branching.","title":"Node Software"},{"location":"node/city-node-software/#mk1-state-machine","text":"Figure 1: Simple node state machine.","title":"MK1 State machine"},{"location":"node/city-node-software/#states-description","text":"","title":"States description"},{"location":"node/city-node-software/#init-state-0","text":"The state in which we initialise the system after powering-up. Read the config file in the external memory (SD card) Configure the system based on the config file Set the wireless connection variable Set the time intervall for the measurements etc... If the file/sd-card is absent trigger a config-file error and go to the error state. Get the current time from a time server Turn off the things we do not need. e.g. the arduino nano iot has an IMU onboard, we do not need it.","title":"Init (state 0):"},{"location":"node/city-node-software/#sleep-state-1","text":"The state in which we sleep until it is time to measure. (Pretty self explanatory). When entered: Set an RTC alarm to wake up for the next measurement. This will use the internal RTC and or the external one (not sure yet). I might rely on the internal one but also set the external one in case we loose power at some point and reset the system. This would allow to keep the measure at a consistent interval. Put the system into the lowest power mode imaginable. Not sure yet if I will wake-up put put to sleep everything here or not. I might also use the IMU to trigger extra measurements based on vibrartions This could be cool to detect small quake or rock slide.","title":"Sleep (state 1):"},{"location":"node/city-node-software/#measure-state-2","text":"The state in which we perfom the enviromental measurements. We can also add some system state measurements. For each measurement: Turn-on the sensor. Wait some time to make sure the sensor is stable (can take several minutes). Get the measurement. Apply correction/calibration / do the computation needed to have the number we will transmit. Turn off the sensor. Some error handling: If problem, generate error code and or enter the error state.","title":"Measure (state 2):"},{"location":"node/city-node-software/#transmit-state-3","text":"The state in which we transmit the measured data to the server. Package the data to be transmited (to gain bandwith and time) This can be a simple \"squeeze\" things into a single word rather than have one per measurement. Will be defined later... Turn on the RF system (wifi, bluetooth, LoRa). Connect to the network. Get some network status data (RF signal strenght etc...). This add to the system status measurements. Connect to the server (Some sort of handshake would be nice). Transmit the data gathered in the previous state. (would be nice to have a transmition confirmation.) This include the environemental data and system status data. Turn off the RF.","title":"Transmit (state 3):"},{"location":"node/city-node-software/#save-state-4","text":"The state in which we save the measured data to the external memory. Power up the SD card. Write the data to SD card with the .CSV format. This might change if I see that .CSV takes too much room. Power down the SD card.","title":"Save (state 4):"},{"location":"node/city-node-software/#error-state-5","text":"The default state where we handle all systen breaking error detected by the system. TO BE COMPLETED","title":"Error (state 5):"},{"location":"node/city-node-transmit-state/","text":"Transmit state Implementation","title":"Transmit state"},{"location":"node/city-node-transmit-state/#transmit-state","text":"","title":"Transmit state"},{"location":"node/city-node-transmit-state/#implementation","text":"","title":"Implementation"},{"location":"server/server-hardware/","text":"Server Requirement and Specifications","title":"Hardware"},{"location":"server/server-hardware/#server-requirement-and-specifications","text":"","title":"Server Requirement and Specifications"},{"location":"server/server-requirement-specs/","text":"Server Requirement and Specifications","title":"Requirements and spec"},{"location":"server/server-requirement-specs/#server-requirement-and-specifications","text":"","title":"Server Requirement and Specifications"},{"location":"server/udp-server/","text":"UDP Server","title":"UDP server"},{"location":"server/udp-server/#udp-server","text":"","title":"UDP Server"},{"location":"server/web-server/","text":"Web server","title":"Web server"},{"location":"server/web-server/#web-server","text":"","title":"Web server"}]}